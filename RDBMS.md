- [关系数据库基本概念](#关系数据库基本概念)
  - [ACID](#acid)
  - [脏读 幻读 不可重复读](#脏读-幻读-不可重复读)
  - [读未提交 读已提交 可重复读 串行化](#读未提交-读已提交-可重复读-串行化)
- [MySQL 相关](#mysql-相关)
  - [InnoDB](#innodb)
    - [聚簇索引与二级索引](#聚簇索引与二级索引)
    - [Redo Log](#redo-log)
    - [Undo Logs](#undo-logs)
    - [Multi-Versioning](#multi-versioning)
    - [快照读](#快照读)
    - [锁](#锁)
      - [共享锁，独占锁](#共享锁独占锁)
      - [意向锁](#意向锁)
      - [记录锁](#记录锁)
      - [间隙锁](#间隙锁)
      - [插入意向锁](#插入意向锁)
      - [Next-Key Lock](#next-key-lock)
    - [不同的sql语句对应的锁](#不同的sql语句对应的锁)
# 关系数据库基本概念

## ACID
A: Atomicity
C: Consistency
I: Isolation
D: Durability

## 脏读 幻读 不可重复读
脏读 当一个事务读取尚未提交的数据时，就会发生脏读。例如，假设事务1更新了一条记录。事务2在事务1提交更新之前读取了更新的行。如果事务1回滚了这个改变，事务2将读取被认为是不存在的数据。

不可重复读 当一个事务两次读取同一行但每次得到不同的数据时，就会发生不可重复读。例如，假设事务1读取了一条记录。事务2提交了对该行更新或删除。如果事务1重新读取该行，就会检索到不同的行值或者发现该行已经被删除。

幻读 幻读是在相同的select条件下，后一次的读取的结果里面增加了第一次读取没有的行。例如，假设事务1读取了一组满足某些搜索条件的行。事务2产生了一条新的符合事务1的检索条件的行（通过更新或插入）。如果事务1重新执行读取这些行的语句，它就会得到一组不同的行。
## 读未提交 读已提交 可重复读 串行化

| 事务隔离级别 | 可能的实现                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 读未提交     | 事务之间不隔离。如果DBMS支持其他的事务隔离级别，它就会忽略它用来实现这些级别的任何机制。为了不对其他事务产生不利影响，在读未提交级别运行的事务通常是只读的。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 读已提交     | 事务会等待被其他事务加写锁的行解锁，这可以防止它读取到任何 "脏 "数据。  事务在当前行上持有一个读锁（如果它只读该行）或写锁（如果它更新或删除该行），以防止其他事务更新或删除它。每个事务在读取当前行时释放读锁，并持有写锁直到它被提交或回滚。                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 可重复读     | 事务会等待被其他事务加写锁的行解锁；这可以防止它读取任何 "脏 "数据。  事务对它返回给应用程序的所有行持有读锁，对它插入、更新或删除的所有行持有写锁。例如，如果事务包括SQL语句`SELECT * FROM Orders`，事务会在应用程序获取行的时候对其进行读锁。如果事务包括SQL语句`DELETE FROM Orders WHERE Status = 'CLOSED'`，那么事务在删除记录时就会对其进行写锁定。  因为其他事务不能更新或删除这些行，当前事务避免了任何不可重复的读取。事务只会在提交或回滚时释放其锁。                                                                                                                                                                                                                |
| 可序列化     | 事务会等待被其他事务加写锁的行解锁；这可以防止它读取任何 "脏 "数据。  事务在其影响的行的范围内持有一个读锁（如果它只读行）或写锁（如果它可以更新或删除行）。例如，如果事务包括SQL语句`SELECT * FROM Orders`，范围是整个Orders表；事务对该表进行读锁，不允许向其中插入任何新行。如果事务包括SQL语句`DELETE FROM Orders WHERE Status = 'CLOSED'`，范围是所有状态为 "CLOSED "的记录；事务对Orders表中所有状态为 "CLOSED "的记录进行写锁，不允许插入或更新任何记录，从而导致记录状态为 "CLOSED"。  因为其他事务不能更新或删除该范围内的行，所以当前事务避免了任何不可重复的读取。因为其他事务不能在该范围内插入任何行，所以当前事务消除了幻读。该事务只会在提交或回滚时释放其锁。 |


# MySQL 相关

## InnoDB

### 聚簇索引与二级索引

每个 InnoDB 表都有一个特殊的索引，称为聚簇索引，用于存储行数据。通常，聚簇索引就是主键。

当表上有定义的PRIMARY KEY时，InnoDB将其用作聚簇索引。

如果没有为一个表定义一个主键，InnoDB会使用第一个UNIQUE索引，所有的键所在的列都定义为NOT NULL，作为聚簇索引。

如果一个表没有PRIMARY KEY或者合适的UNIQUE索引，InnoDB会在一个包含行ID值的合成列上生成一个名为GEN_CLUST_INDEX的隐藏聚簇索引。行是由InnoDB分配的行ID来排序的。行ID是一个6字节的字段，随着新行的插入而单调地增加。因此，按行ID排序的行在物理上是按插入的顺序排列的。

除了聚簇索引以外的索引被称为二级索引。在InnoDB中，二级索引中的每条记录都包含了该行的主键列，以及二级索引所索引的列。InnoDB使用这个主键值来聚簇索引中搜索记录。

### Redo Log

redo log是一个基于磁盘的数据结构，在崩溃恢复期间用于纠正由不完整事务写入的数据。在正常操作期间，redo log对改变表数据的SQL语句或低级别的API调用进行编码。在意外关机前没有完成的对数据文件的修改会在数据库初始化期间和接受连接之前自动重放。

### Undo Logs

一个Undo log是一个与某一读写事务相关的undo log records的集合。一个undo log record记录包含了关于如何撤销事务对聚簇索引记录的最新修改的信息。如果另一个事务需要通过快照读看到某一过去版本的数据，该版本的数据会从undo log记录中检索出来。undo log存在于undo log段中，该段包含在回滚段中。回滚段存在undo tablespaces和全局临时表空间中。

存储在全局临时表空间中的undo log用于修改用户定义的临时表的数据的事务。这些undo log没有被列入redo log，因为它们不需要用于崩溃恢复--它们只在服务器运行时用于回滚。这种类型的undo log由于避免了redo log的I/O从而提升性能。

### Multi-Versioning

隐式的，InnoDB为存储在数据库中的每一条记录添加三个字段。

一个6字节的DB_TRX_ID字段表示插入或更新该行的最后一个事务的标识符。另外，一个删除被视为一个更新，并将改行通过一个特殊位标记为已删除。

一个7字节的DB_ROLL_PTR字段称为滚动指针。滚动指针指向写在rollback segment上的rollback日志记录。如果该行被更新了，rollback日志记录包含了重建该行被更新前内容的必要信息。

一个6字节的DB_ROW_ID字段包含一个行的ID，这个ID随着新行的插入而单调地增加。如果InnoDB自动生成了一个聚簇索引，那么该索引就包含了行ID值。否则，DB_ROW_ID列不会出现在任何索引中。


### 快照读

快照读是指InnoDB使用Multi-Versioning来向查询展示数据库在某个时间点的快照。查询看到的是在该时间点之前提交的事务所做的改变，而无法看到以后的或未提交的事务所做的改变。这个规则的一个例外是查询依然可以看到同一事务中之前语句所做的改变。这个例外会导致以下异常：如果你更新了表中的一些行，SELECT会看到最新版本的更新行，但是它同时也可能看到任何其他的旧版本的行。如果其他事务同时更新同一个表，这个异常现象意味着你可能会看到数据库中从未存在过的表的状态。

如果事务隔离级别是可重复读，那么同一事务中的所有一致读取都会读取该事务中第一个此类读取所建立的快照。你可以通过提交当前事务并在之后发布新的查询来为你的查询获得一个更新鲜的快照。

在都已提交隔离级别下，事务中的每个一致读取都会设置并读取自己的最新快照。

### 锁

#### 共享锁，独占锁

InnoDB实现了标准的行级锁，有两种类型的锁，共享（S）锁和独占（X）锁。

一个共享（S）锁允许持有该锁的事务读取一条记录。

独占（X）锁允许持有该锁的事务更新或删除一条记录。

#### 意向锁

InnoDB支持多粒度锁，允许行锁和表锁共存。例如，诸如`LOCK TABLES ... WRITE`这样的语句在指定的表上取得了一个独占锁（X锁）。为了使多个粒度级别的锁切实可行，InnoDB使用意图锁。意图锁是表级别的锁，它表明事务以后需要对表中的某一行进行哪种类型的锁（共享或独占）。有两种类型的意向锁。

意向共享锁（IS）表示一个事务打算在表中的个别行上设置一个共享锁。

意向独占锁（IX）表示一个事务打算在表中的个别行上设置一个排他锁。

例如，`SELECT ... FOR SHARE`设置一个IS锁，`SELECT ... FOR UPDATE`设置一个IX锁。

意向锁规则如下:

- 在一个事务可以获得表内某行的共享锁之前，它必须首先获得该表的IS锁或更强的锁。
- 在事务可以获得表中某行的独占锁之前，它必须首先获得该表的IX锁。

下表总结了**表级锁**的冲突关系

|     | X    | IX     | S      | IS     |
| --- | ---- | ------ | ------ | ------ |
| X   | 冲突 | 冲突   | 冲突   | 冲突   |
| IX  | 冲突 | 不冲突 | 冲突   | 不冲突 |
| S   | 冲突 | 冲突   | 不冲突 | 不冲突 |
| IS  | 冲突 | 不冲突 | 不冲突 | 不冲突 |

意向锁不会阻塞除完整表请求之外的任何内容（例如，`LOCK TABLES ... WRITE`）。 意向锁的主要目的是表明有事务正在锁定一行，或者将要锁定表中的一行。

#### 记录锁

记录锁是针对一个索引记录的锁。例如，`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;`会组织任何其他事务插入、更新或删除表t中c1的值为10的记录。

记录锁总是锁定索引记录，即使一个表没定义索引（InnoDB将使用生成的聚簇索引）。

#### 间隙锁

间隙锁会锁住两个索引条目中间，或者第一条索引前以及最后一条索引记录后。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`会阻止其他事务向列t.c1插入一个15的值，无论该列中是否已经有这样的值，因为该范围中所有值都被间隙锁锁定。

间隙锁是性能和并发性之间权衡的一部分，仅在一些事务隔离级别中使。

对于使用唯一索引来搜索某一行导致的加锁场景，间隙锁是不必要的。(这不包括搜索条件只包括多列唯一索引中的一些列的情况；在这种情况下，间隙锁定会发生。) 

这里还值得注意的是，不同的事务可以在一个间隙上持有**相互冲突**的锁。例如，事务A可以在一个间隙上持有共享间隙锁），而事务B在同一个间隙上持有排他性间隙锁。允许冲突的间隙锁的原因是，如果一条记录从索引中被清除，不同的事务对该记录持有的间隙锁必须被合并。

InnoDB中的间隙锁是 "纯抑制性 "的，这意味着它们的唯一目的是防止其他事务将数据插入到间隙中。间隙锁可以同时存在。一个事务使用的间隙锁并不妨碍另一个事务在同一间隙上使用间隙锁。共享间隙锁和独占间隙锁之间没有区别。它们不会相互冲突，而且执行同样的功能。

#### 插入意向锁

插入意向锁是在插入前设置的**间隙锁**。这种锁发出了插入意图的信号，如果多个事务在同一索引间隙中插入的位置不一样，就不需要互相等待。假设有数值为4和7的索引记录。有两个事务分别试图插入值为5和6的条目，在获得插入行的独占锁之前，各自用插入意图锁锁定了4和7之间的间隙，但是由于这些行是不冲突的，所以不会相互阻塞。

插入意向锁与普通间隙锁依然会互相冲突。

#### Next-Key Lock

一个Next-Key Lock是一个索引记录上的记录锁和该索引记录前的间隙锁的组合。

InnoDB执行行级锁的方式是，当它搜索或扫描一个表的索引时，它对遇到的索引记录设置共享或独占锁。因此，行级锁实际上是索引记录的锁。一个索引记录上的Next-Key Lock也会影响到该索引记录之前的 "间隙"。也就是说，Next-Key Lock是一个记录锁加上索引记录之前的空隙锁。如果一个会话对索引中的记录R有一个共享或排他的锁，另一个会话就不能在索引顺序中紧挨着R的空隙中插入一个新的索引记录。

### 不同的sql语句对应的锁

锁定读取、UPDATE或者DELETE通常会对当前SQL语句中扫描到的每一条索引记录设置记录锁。语句中是否有排除该行的WHERE条件并不重要。InnoDB并不使用确切的WHERE条件来决定某些行是否应该被锁定，而只使用索引范围。这些锁通常是NEXT-KEY Lock。

如果没有针对该语句条件的索引，MySQL必须扫描整个表来处理该语句，导致该表的每一行都会被锁定，因此会阻止其他用户对该表的所有插入。创建良好的索引是很重要的，这样你的查询就不会扫描不必要的行。

`SELECT ... FROM`是一个一致非阻塞读，并且不设置锁，除非事务隔离级别被设置为SERIALIZABLE。对于SERIALIZABLE级别，会使用Next-Key Lock。

使用唯一索引的`SELECT ... FOR UPDATE`和`SELECT ... FOR SHARE`语句为扫描到的行添加锁，并为不满足行释放锁（例如，如果不符合WHERE子句的记录）。然而，在某些情况下，行可能不会被立即解锁。例如，在UNION中，从表中扫描（和锁定）的行可能会在评估它们是否符合条件之前被插入到一个临时表中。在这种情况下，临时表中的行与原表中的行的关系就会丢失，这种情况下原表中行在查询结束后才会解锁。

对于锁定读取（带有FOR UPDATE或FOR SHARE的SELECT）、UPDATE和DELETE语句，所采取的锁取决于该语句是使用带有唯一搜索条件的唯一索引还是使用范围型搜索条件。

对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不是它之前的间隙。

对于其他的搜索条件，以及非唯一索引，InnoDB锁定所扫描的索引范围，使用间隙锁或者Next-Key Lcok来阻止其他会话插入到范围所覆盖的间隙中。

对于搜索遇到的索引记录，`SELECT ... FOR UPDATE`会阻止其他事务进行`SELECT ... FOR SHARE`。快照读会忽略全部锁。

`UPDATE ... WHERE ...` 在搜索遇到的每条记录上设置一个独占的Next-Key Lock。然而，对于限定唯一索引中某一单独条目的的，只需要一个记录锁。

当UPDATE修改一个聚簇索引记录时，会在受影响的二级索引记录上隐式加锁。在插入新的二级索引记录之前通过扫描来进行重复条目检查，以及插入新的二级索引记录时，UPDATE也会在受影响的二级索引记录上加上共享锁。

`DELETE FROM ... WHERE ...` 在搜索遇到的每条记录上设置一个独占的Next-Key Lock。同样地，如果限制条件为某唯一索引中的唯一条目，只需要加记录锁。

`INSERT`在插入的行上设置一个独占锁。这个锁是一个记录锁，因此不会阻止其他会话插入到插入行之前的间隙。

当然，在`INSERT`前会插入上文提到的插入意向锁。

如果插入过程中发生重复键错误，重复的索引记录上会被设置一个共享锁。如果有多个会话试图插入同一行，而另一个会话已经有一个独占锁，那么这种共享锁的使用可能会导致死锁。例如事务A删除行a，并已经获取了独占锁，此时事务B，C都试图插入行a从而发生重复键错误。在事务A删除完成后，事务B，C同时获得共享锁，因此导致死锁。

`INSERT ... ON DUPLICATE KEY UPDATE`与简单的INSERT不同的是，当发生重复键错误时，重复的行上会被放置一个独占锁而不是共享锁。对于一个重复的主键值，会使用独占记录锁。而对于重复的非主键唯一键值，会使用独占的Next-Key Lock。

如果在一个唯一键上没有碰撞，REPLACE就像INSERT一样进行。否则，一个独占的Next-Key Lock将锁住被替换的行上。

`INSERT INTO T SELECT ... FROM S WHERE ...` 在插入到T的每一条记录上设置一个独占记录锁。如果事务隔离级别是 READ COMMITTED，InnoDB在S上进行快照读。 否则，InnoDB将为读取到的S的行设置共享的 Next-Key Lock。

`CREATE TABLE ... SELECT ...` 像`INSERT ... SELECT`一样使用共享的Next-Key Lock，或者快照读来执行SELECT。

当SELECT被用于构造`REPLACE INTO T SELECT ... FROM S WHERE ...`或者`UPDATE T ... WHERE col IN (SELECT ... FROM S ...)`，InnoDB对表S的记录设置共享的Next-Key Lock。

InnoDB在初始化表的一个AUTO_INCREMENT列时，在与AUTO_INCREMENT列相关的索引的末端设置了一个独占锁。


来源：
- https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/transaction-isolation-levels?view=sql-server-ver16
- https://dev.mysql.com/doc/refman/8.0/en